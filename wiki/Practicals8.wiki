= How to link VMS data with other spatial datasets =

== Introduction ==
The number of VMS data requests and analyses have gone up tremendously over the past years. The number of papers written on VMS analyses have followed this increase too. Many of them deal with issues like: how should you clean your data, how should you link VMS and logbook data, what grid size is best to use and also how to calculate your indicators. This already shows that although most of the tools are available, at the advisory level, no consensus has been reached as yet on how exactly to tackle these issues.

At the same time, VMS and logbook data are associated with confidentiality issues, which makes it much more difficult to combine datasets of different nations. Although VMStools presents a framework that can be applied by many different nations at exactly the same manner, also combined with the FishFrame database that might hold VMS data at some point, no such results have been reported yet. 

Most of you are here however to do science, and contributing to the discussions outlined above might not be as satisfactory for you. Well, here is a challenge! So far, hardly any papers have discussed the relationship between VMS and covariates as temperature, seabed or wave hight. Why not? Potentially because it is difficult to line all these different datasets up and do the statistics. 

Within this practical I'll show you how you can start exploring these interesting aspects, which was one of the core goals to develop VMStools: to quickly deal with the 'un-interesting stuff' of cleaning and linking and get to the explanatory relationships as soon as possible!

== Getting and preparing spatial data ==
One requirement of spatial data is that it contains some sort of position identifier. This could be a shapefile / polygon or a longitude-latitude position(like the start or midpoint of a survey trawl). 

In this practical I'll show how to link VMS data with such a shapefile (habitat) and with some phyto plankton data.

=== Link VMS with habitat map ===
The good thing about habitat (as in substrate) is that is doesn't change much over time. Once somebody has created a map, you can use it for quite some time and there is no need to update your code. Please now download the [http://code.google.com/p/vmstools/downloads/list HabitatMaps.zip], store it somewhere on your harddrive (somewhere easy, because you need to link to at later on) and unzip it!

The habitat map is a shapefile and we'll make some plots first to see what it is all about. Thereafter we'll link VMS points up with the habitats and show where most of e.g. the beam trawling has taken place.

<code>
#Find the path to your habitat map 
>path <- "D:/HabitatMaps/"
>habitat <- readShapePoly(paste(path,"ModelledSeabedHabitats.shp",sep=""))

#We can simply plot it
>plot(habitat) #But it doesn't make much sense...
>names(habitat)
>slotNames(habitat)
#The way the file is constructed is that it has a large number of polygons (167). 
#Each of these polygons can be associated with e.g. substrate or salinity. 
#The same polygons are used for substrate and salinity but the polygons belonging to the same substrate is not necessarily the same polygons that belong to the same salinity value. 

#Let's plot the substrate types around the North Sea
>require(maps);require(mapdata)
>map("worldHires",xlim=c(-5,10),ylim=c(48,62),fill=T,col="darkgreen"); 
#What substrate levels do we have?
>levels(habitat$substrate) #apparently 7 different substrates
#Define 7 different colors
>colrs <- c(
"lightblue","brown","yellow","slategray","green","red",
"blue")
#Turn the polygons into spatial polygons
>sp <- SpatialPolygons(habitat@polygons)
#Look at the order of plotting
>sp@plotOrder
>plot(sp,col=colrs[an(habitat$substrate)],border=colrs[an(habitat$substrate)],add=T)
>lcolrs <- length(colrs)+1
>legend("bottomleft",legend=c("Land",levels(habitat$substrate)),
        lwd=c(1,1,1,1),lty=rep(NA,10),pch=rep(22,lcolrs),ncol=2,
        col=rep("black",lcolrs), pt.bg=c("darkgreen",colrs),pt.cex=rep(3,lcolrs),box.lty=1,box.lwd=2,
        y.intersp=1.5,title="Substrate type",bg="white",cex=0.5)
>map.axes()
</code>
You might get puzzled from such shapefiles but after a while you'll get a grip on how to handle those! Let's see if we can link VMS pings with substrate type. We must be careful now however. This particular shapefile contains polygons inside polygons. So, if we test if one VMS ping is inside any of the polygons, it might hit 'yes' more than once. So, which one is the right one? Luckily, the file also comes with a plotting order, we need to watch that!
<code>
#Let's take an example point, e.g. lon,lat = 4.8,54.2. This must be located inside 'Mud to sandy mud'. However, we must be careful here, as the point will be inside more than 1 polygon of the dataset!
<code>
#First the easy and automated way
>pnt <- c(4.8,54.2)
#Turn the point into a spatial point
>spo <- SpatialPoints(coordinates(data.frame(SI_LONG=pnt[1],
                                            SI_LATI=pnt[2])))
#Use the magic 'overlay' function to see in which polygon it is located
>idx <- overlay(spo,sp); print(idx)
>habitat$substrate[idx]
</code>
That wasn't too difficult, and you didn't notice the polygon inside polygon issue at all. That is how nice these things could work. Note that you can have multiple points inside the SpatialPoints. However, if you want / need to do these calculations yourself (because you not only want to perform these analyses, but also want to fully understand what is going on), here is some Do It Yourself code!
<code>
#Create a vector with zeros representing each of the polygons
# Note that for our point can be inside more than one polygon, therefore we have one value (zero or one) for each polygon.
>insidePols <- rep(0,length(habitat@polygons))
>for(i in 1:length(habitat@polygons)){
  for(j in 1:length(habitat@polygons[[i]]@Polygons)){
    pol <- coordinates(habitat@polygons[[i]]@Polygons[[j]])
    insidePols[i] <- max(insidePols[i],point.in.polygon(pnt[1],pnt[2],pol[,1],pol[,2]))
  }
}
#Check inside which polygon our point is situated
>idx <- which(insidePols == 1)
>print(habitat$substrate[idx])
#This is tricky, we need to define in which substrate the point lies but keep track of the plot order!
>habitat$substrate[idx][which.max(order(habitat@plotOrder)[idx])]
</code>
The main 'engine' of most of these calculations is the point.in.polygon function which is very powerful, but the way it's code above is very inefficient for just one point!

Time to find some relationships. Let's take some beamtrawl fishers only and see what type of substrate they normally trawl. Do you have a gut-feeling already?
<code>
>data(tacsat);data(eflalo)
>tacsatp <- mergeEflalo2Tacsat(eflalo,tacsat)
>tacsatp$LE_GEAR <- eflalo$LE_GEAR[match(tacsatp$FT_REF,eflalo$FT_REF)]
>tacsat  <- subset(tacsatp,LE_GEAR == "TBB")
>tacsat  <- sortTacsat(tacsat)
>tacsat  <- filterTacsat(tacsat,c(2,6),hd=NULL,remDup=T)

#All the preparation is done now, let's overlay these VMS points with the habitat map (I am interested in substrate)
>spo     <- SpatialPoints(coordinates(tacsat[,c("SI_LONG","SI_LATI")]))
>sp      <- SpatialPolygons(habitat@polygons)
>idx     <- overlay(spo,sp) #Get a cup of coffee, this might take a while...!
>tacsat$SUBSTRATE <- habitat$substrate[idx]
>table(tacsat$SUBSTRATE)

</code>
=== Link VMS with phyto plantkon map ===