= Practical 7: Output to Fishframe and GIS =

== Output to FishFrame ==

  * Here we describe a method due to Bastardie et at. (2010) for simultaneously coupling VMS and logbook data and then distributing the landings or their cash values among VMS positions estimated to be actively fishing.

  * The first step is to work out the proximity of each VMS data point to each fishing port.  Linking each VMS trip to each logbook trip is done by searching for the nearest trip among all logbook trips based on the temporal mid-point of trips.  Note: that the method described here differs from that due to Hintzen and described in Practical 3.

  * After linking VMS and logbook data, gear types can be assigned to each VMS position enabling fishing activity, or otherwise, to be identified using the segmented regression approach described earlier. 

  * The next step is to evaluate the consistency between each of the two separate data sources (VMS vs logbook). This proces is described in detail by Bastardie et al. (2010). 

  * Finally the landings (in both weight and cash value) declared in the logbooks are allocated to each VMS position. 

  * The data can then be reshaped and aggregated into any other format and the example used here is FishFrame. It is worth noting that R-scripts like the one described below for our 'Atlantis' data can of course be run on VMS and logbook data for any different country to produce aggregated datasets in common formats that can be combined and exchanged without violoting data protection laws. 

  * The scripting method ensures that each dataset is processed in an identical way and is repeatable.


==Getting started==
As usual we have to add the inbuilt data sets to R's search path, install the vmstools library, and 'clean' the data prior to any analysis.

Loading the library, a usual start to every analyses.

<code>
>library(vmstools)   
</code>

Hereafter, as we've seen before, we need to load the logbook, VMS and harbour data to have access to these data sources.
   
<code>                  
>data(eflalo)                            
>data(tacsat)        
>data(euharbours)                        
>euharbours <- harbours   
</code>             

As usual, and especially necessary for your own data, format the data.

<code>
>eflalo <- formatEflalo(eflalo)
>tacsat <- formatTacsat(tacsat)
>tacsat <- sortTacsat(tacsat)
</code>

The code that turns the data into FishFrame data has a slightly different setup than the other function's you've seen so far. Especially the way logbook and VMS data are linked is different and it requires a pre-definition of point ins harbour. Here we test whether VMS positions are in harbour or not.

<code>  
>tacsat$SI_HARB <- NA
>euharbours$Description <- euharbours$harbour
>tacsat$SI_HARB <- pointInHarbour(lon=anf(tacsat$SI_LONG),
                                   lat=anf(tacsat$SI_LATI),
                                   harbours=harbours,
                                   rowSize=30, returnNames=TRUE)
  
>inHarb <- tacsat$SI_HARB
>inHarb <- replace(inHarb, !is.na(inHarb), 1)
>inHarb <- replace(inHarb, is.na(inHarb), 0)
>inHarb <- as.numeric(inHarb)
</code>

Once we've defined which points are in harbour, the functionality requires some sort of trip identifier.

<code>
>tacsat$SI_FT <- 1 # init
>idx <- which(inHarb==0)
>tacsat[idx,"SI_FT"] <- cumsum(inHarb) [idx] # add a SI_FT index

</code>

Linking logbooks and VMS is defined based on mid-points of trips and therefore requires points outside of a harbour but also the departure and arrival dates.

<code>
>startTrip <- c(diff(tacsat[,"SI_FT"]), 0)
>endTrip   <- c(0, diff(tacsat[,"SI_FT"]))
>tacsat[which(startTrip>0),"SI_FT"]  <-  tacsat[which(startTrip>0)+1,"SI_FT"] 
>tacsat[which(endTrip<0),"SI_FT"]    <-  tacsat[which(endTrip<0)-1,"SI_FT"] 
 >tacsat <- tacsat[which(inHarb==0 |  startTrip>0 |  endTrip<0),]
</code>

Now assign activity state (e.g. fishing v steaming) to each ping. Note that this is optional. If detectFishing = TRUE in mergeEflalo2Pings then the function/code will do this part automatically. You might want, for example, to apply your own rules to identify fishing. You can do it here setting detectFishing = FALSE
<code>
>tacsat$SI_STATE <- 2 # init (1 = fishing; 2 = steaming)
>tacsat$SI_STATE [(tacsat$SI_SP>4 & tacsat$SI_SP<8)] <-1
</code>

Sometimes you get naming mistakes and below is some example code that might be useful to deal with these:
<code>
#    if(!match('LE_MET_level6',colnames(eflalo))>0){
#      eflalo$LE_MET_level6 <- eflalo$LE_MET
#    }
</code>

In this example we run the code for a given set (50 random ones) of vessels in the year 1800. Since detectFishing = TRUE (see below) then the code is also detecting fishing activity using the built-in function segmentTacsatSpeed(). [Note that this will overwrite the existing SI_STATE]. First we set up some variables we need,ie. a year variable, and a vector for the unique boat names and also the total number of boats that we intend to output data for.

<code>  
>tacsat$year <- as.numeric(format(tacsat$SI_DATIM, format = "%Y")) 
>how.many.boats.in.tacsat <- length(unique(tacsat$VE_REF     [tacsat$year==1800]))  #Take data for 1800 
>no.of.boats              <- 50 # lets's do 50 boats
>which.boats <- unique(tacsat$VE_REF)[seq(1,how.many.boats.in.tacsat,length=no.of.boats)]

</code>

This code writes data to the c:\\ drive so it's safe to clean it out first to avoid confusion:

<code>
 >unlink("c:\\output\\*") #delete everything in c:\\output to avoid confusion.
</code>

Now run the main program that does all the work. You will note pictures popping up etc. These can all be found in c:\\output and describe the matching of the VMS to logbook data and how fishing was identified for each vessel.

<code>  
 >mergeEflalo2Pings (eflalo=eflalo, tacsat=tacsat, vessels=which.boats,
                     general=list(output.path=file.path("C:","output"),
                     visual.check=TRUE, detectFishing=TRUE, speed="segment",
                     what.speed="calculated"))

</code>

Another option might be to run the code for ALL the vessels you have available. The code to do this is described below should you want to try...
<code>
#>mergeEflalo2Pings (eflalo=eflalo, tacsat=tacsat,
#                     general=list(output.path=file.path("C:","output"),
#                     visual.check=TRUE, detectFishing=TRUE, speed="segment",
#                     what.speed="calculated"))
</code>

Tidy up the results in your R directory
<code>
>gc(reset=TRUE)
</code>


Similarly you might want to load the merged output table for one vessel, say vessel "10" for the year 1800 and check whether all the landings in eflalo (logbook) have actually been allocated to VMS positions, which we do below:
<code>
>load(file.path("C:","output","merged_10_1800.RData"))
>merged.10 <- merged

>sum(tapply(anf(merged$LE_KG_PLE), merged$flag, sum, na.rm=TRUE))
>sum(eflalo[eflalo$VE_REF=="10","LE_KG_PLE"], na.rm=TRUE)
</code>

Alternatively we can bind up all 50 vessels keeping the file sizes manageable by selecting just a few species:
<code>  
>bindAllMergedTables (vessels=which.boats, a.year = "1800",
                      species.to.keep=c("PLE","COD","SOL","DAB","TUR"),
                      folder = file.path("C:","output"),
                      all.in.one.table=TRUE)
</code>

We then load up the merged output table for all 50 vessels:
<code> 
  load(file.path("C:","output","all_merged__1800.RData"))
</code>

Switch graphics off
<code>
>graphics.off()
</code>

Time to map the data!
<code>
# Select columns of interest
>df1<- all.merged[, c("SI_LATI","SI_LONG","LE_KG_COD","LE_KG_PLE","LE_KG_SOL","LE_KG_DAB","LE_KG_TUR")]
>df1$SI_LONG <- anf(df1$SI_LONG)
>df1$SI_LATI <- anf(df1$SI_LATI)
>df1 <-   df1[ !is.na(df1$SI_LATI),]
>df1 <-   df1[ !is.na(df1$SI_LONG),]

#Chose species to look at
  
>what.species.to.map <- "LE_KG_PLE" 
  
#Remove steaming points before plotting:
 
>df2<-df1[-which(is.na(df1[,what.species.to.map])),]
  
>vmsGridCreate(df2,nameLon="SI_LONG",nameLat="SI_LATI", we = 3, ea = 6, so = 50, no = 54,
                nameVarToSum = what.species.to.map,cellsizeX =0.05,
                cellsizeY =0.05,  legendtitle = paste(substr(what.species.to.map,7,9)," landings (kg)")
                , plotPoints =TRUE, breaks0=c(1,4,8,16,32,64,100000))

</code>

Now convert to FishFrame format which might take some time running. By default this function will keep all the species in the output table
<code>
# First bind up all the tables in c:\\output

>tmp <- bindAllMergedTables (vessels=which.boats,
                              species.to.keep=character(),
                              folder = file.path("C:","output"),
                              all.in.one.table=FALSE)
#Now create FishFrame data

>ff  <- pings2Fishframe (general=list(output.path=file.path("C:","output"),
                          a.year=1800, a.country="NLD") )

</code>

Note that the file of interest (FishFrame format) will be in c:\\output and is called for this run of the script, NLD1800_VD.csv. Open it in Wordpad or similar and have a look at it

==Output to more formal GIS:==

Run similar code as described above but add in the argument.
<code>

# Set up desired grid size and range
>grid.size <- 0.06
>we <- -3
>ea <- 10
>so <- 49
>no <- 59

#Directory to put output file in and name of file

>setwd('c://output')
>outfile <- 'fishlandings.asc'

#Run the function vmsGridGreate which has an option to output an ASCII grid that is in ArcView format but can be read by other GIS programs

>output.mat<-vmsGridCreate(df2, we=we,ea=ea,so=so,no=no,nameLon = "SI_LONG", nameLat = "SI_LATI",plotMap=F,
nameVarToSum="LE_KG_PLE",cellsizeX = grid.size, cellsizeY = grid.size,
legendx="bottomright",numCats=9,plotPoints=F,legendncol=2,legendtitle="kgs",outGridFile=outfile)

</code>

Now go get and install QGIS (http://www.qgis.org/). Find the file fishlandings.asc in c:\\output and load into QGIS as a raster layer. Other options are to produce the output in Google Earth see below:

<code>

Another free and very good GIS system is Google Earth which you can use easily with our vmstools library:
<code>
# Create an output file

fn<-'landings'

# Run the function Grid2KML:

Grid2KML(output.mat=output.mat,what.quantity = 'kgs',kmlfile=paste(fn,'.kml',sep=''),imagefile=paste(fn,'.png',sep=''))

# Go to c":\\output and click on the kml file to examine your data in GE.
</code>
















 