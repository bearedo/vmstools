#summary One-sentence summary of this page.

= Practical 7: Output to Fishframe and GIS =

== Introduction ==

  * Here we describe a method due to Bastardie et at. (2010) for simultaneously coupling VMS and logbook data and then distributing the landings or their cash values between among VMS positions estimated to be actively fishing.

  * The first step is to work out the proximity of each VMS data point to each fishing port.  Linking of each VMS trip to each logbook trip is done by assigning a common identifier by searching for the nearest trip among all logbook trips based on the temporal mid-point of trips.  Note: that the method described here differs from that due to Hintzen and described in Practical ?????

  * After linking VMS and logbook data, gear types can be assigned to each VMS position thus enabling fishing activity or otherwise to be identified using segmented regression describer earlier. 

  * The next step is to evaluate the consistency between each data sources (VMS vs logbook) which is described by Bastardie et al. (2010). 

  * Finally the landings (in both weight and cash value) declared in the logbooks (by ICES rectangle) are further allocated to each VMS position. 

  * The data can then be reshaped and aggregated into any other format. R-scripts like the one described below for our 'Atlantis' data can of course be run on VMS and logbook data for any different country to produce aggregated datasets in common formats that can be combined and exchanged without violoting data protection laws. 

  * The scripting method ensures that each dataset is processed in an identical way and is repeatable.


==Getting started==
As usual we have to add the inbuilt data sets to R's search path, install the vmstools library, 'clean' and process the data prior to any analysis.

===Install the library===

<code>

>library(vmstools)   

</code>

===Increase memory to maximum===

<code>

>memory.size(4000)  

</code>

===Install the logbook, VMS and harbour data===
                     
>data(eflalo)                            

>data(tacsat)        
                      
>data(euharbours)   

# Re-name the harbour database
                     
>euharbours <- harbours                

# Format the data as usual

>eflalo <- formatEflalo(eflalo)
>tacsat <- formatTacsat(tacsat)

# Order tacsat chronologically with sortTacsat

>tacsat <- sortTacsat(tacsat)

# Test whether VMS positions are in harbour or not
  
>tacsat$SI_HARB <- NA
>euharbours$Description <- euharbours$harbour
>tacsat$SI_HARB <- pointInHarbour(lon=anf(tacsat$SI_LONG),
                                   lat=anf(tacsat$SI_LATI),
                                   harbours=harbours,
                                   rowSize=30, returnNames=TRUE)
  
>inHarb <- tacsat$SI_HARB
>inHarb <- replace(inHarb, !is.na(inHarb), 1)
>inHarb <- replace(inHarb, is.na(inHarb), 0)
>inHarb <- as.numeric(inHarb)

# Assign a trip identifier

>tacsat$SI_FT <- 1 # init
>idx <- which(inHarb==0)
>tacsat[idx,"SI_FT"] <- cumsum(inHarb) [idx] # add a SI_FT index

# Keep 'out of harbour' points but also the departure and the arrival points.

>startTrip <- c(diff(tacsat[,"SI_FT"]), 0)
>endTrip   <- c(0, diff(tacsat[,"SI_FT"]))
>tacsat[which(startTrip>0),"SI_FT"]  <-  tacsat[which(startTrip>0)+1,"SI_FT"] 
>tacsat[which(endTrip<0),"SI_FT"]    <-  tacsat[which(endTrip<0)-1,"SI_FT"] 
 >tacsat <- tacsat[which(inHarb==0 |  startTrip>0 |  endTrip<0),]


# Assign activity state (e.g. fishing v steaming) to each ping. Note that this is optional.
#If detectFishing = TRUE in mergeEflalo2Pings the function/code will do this part ) 

>tacsat$SI_STATE <- 2 # init (1 = fishing; 2 = steaming)

  
# Rule for fishing state based on speed.
  
tacsat$SI_STATE [(tacsat$SI_SP>4 & tacsat$SI_SP<8)] <-1


  # reduce the size of the eflalo data by merging species
  # (assuming that the other species is coded MZZ), threshold in euros.
  # eflalo2 <- poolEflaloSpecies (eflalo, threshold=1e6, code="MZZ")

  # debug if eflalo has not been cleaned earlier
  # eflalo <- eflalo[!eflalo$VE_REF=="NA" &!is.na(eflalo$VE_REF),]
  
  # an informed VE_FLT is also required
  if(all(is.na(eflalo$VE_FLT))) eflalo$VE_FLT <- "fleet1"
  
  ## possible mis-naming mistakes
#    if(!match('LE_MET_level6',colnames(eflalo))>0){
#      eflalo$LE_MET_level6 <- eflalo$LE_MET
#    }

  ## debug
#  eflalo <- eflalo[eflalo$LE_MET!="No_logbook6",]
#

  # TEST FOR A GIVEN SET OF VESSELS
  # (if detect.fishing is true then do also detection of fishing *<br/>* activity
  # e.g. if speed='segment' the segmentTacsatSpeed() automatic *<br/>* detection of fishing states
  # that will overwrite the existing SI_STATE)
  
  tacsat$year <- as.numeric(format(tacsat$SI_DATIM, format = "%Y")) 

  how.many.boats.in.tacsat <- length(unique(tacsat$VE_REF[tacsat$year==1800]))  #Take data for 1800 
  no.of.boats              <- 50 # lets's do 50 boats
  which.boats <- unique(tacsat$VE_REF)[seq(1,how.many.boats.in.tacsat,length=no.of.boats)]
  
  unlink("c:\\output\\*") #delete everything in c:\\output to avoid confusion.
  
  mergeEflalo2Pings (eflalo=eflalo, tacsat=tacsat, vessels=which.boats,
                     general=list(output.path=file.path("C:","output"),
                     visual.check=TRUE, detectFishing=TRUE, speed="segment",
                     what.speed="calculated"))
  # ...OR APPLY FOR ALL VESSELS IN eflalo
  #mergeEflalo2Pings (eflalo=eflalo, tacsat=tacsat,
#                     general=list(output.path=file.path("C:","output"),
#                     visual.check=TRUE, detectFishing=TRUE, speed="segment",
#                     what.speed="calculated"))
  gc(reset=TRUE)

  ## load the merged output table for one vessel
#  load(file.path("C:","output","merged_10_1800.RData"))
#  
#  merged.10 <- merged
#
#  # check the conservation of landings
#  sum(tapply(anf(merged$LE_KG_PLE), merged$flag, sum, na.rm=TRUE))
#  sum(eflalo[eflalo$VE_REF=="10","LE_KG_PLE"], na.rm=TRUE)
#

   # ...or bind all vessels (keeping only some given species here)
  
  bindAllMergedTables (vessels=which.boats, a.year = "1800",
                      species.to.keep=c("PLE","COD","SOL","DAB","TUR"),
                      folder = file.path("C:","output"),
                      all.in.one.table=TRUE)

    # ...and load the merged output table for all vessels
  
  load(file.path("C:","output","all_merged__1800.RData"))

  # map landing of cod from all studied vessels
  # ( with debugging if tacsat has not been cleaned earlier)
  graphics.off()
 
  df1<- all.merged[, c("SI_LATI","SI_LONG","LE_KG_COD","LE_KG_PLE","LE_KG_SOL","LE_KG_DAB","LE_KG_TUR")]
  
  
  df1$SI_LONG <- anf(df1$SI_LONG)
  df1$SI_LATI <- anf(df1$SI_LATI)
  df1 <-   df1[ !is.na(df1$SI_LATI),]
  df1 <-   df1[ !is.na(df1$SI_LONG),]
  
  what.species.to.map <- "LE_KG_PLE"
  
 
 # but you need to remove steaming points before gridding!
 
  df2<-df1[-which(is.na(df1[,what.species.to.map])),]
  
  vmsGridCreate(df2,nameLon="SI_LONG",nameLat="SI_LATI", we = 3, ea = 6, so = 50, no = 54,
                nameVarToSum = what.species.to.map,cellsizeX =0.05,
                cellsizeY =0.05,  legendtitle = paste(substr(what.species.to.map,7,9)," landings (kg)")
                , plotPoints =TRUE, breaks0=c(1,4,8,16,32,64,100000))



  # CONVERT TO FISHFRAME FORMAT (might take some time running)
  # (by default, this will keep all the species in the output table)
  tmp <- bindAllMergedTables (vessels=which.boats,
                              species.to.keep=character(),
                              folder = file.path("C:","output"),
                              all.in.one.table=FALSE)

  ff  <- pings2Fishframe (general=list(output.path=file.path("C:","output"),
                          a.year=1800, a.country="NLD") )

  
## End(Not run)

vsl <- mergedTable2FishframeVSL (general=list(output.path=file.path("C:","noutput"),a.year=2009, a.country="NLD") )
  ve <- mergedTable2FishframeVE (general=list(output.path=file.path("C:","noutput"),a.year=2009, a.country="NLD") )
